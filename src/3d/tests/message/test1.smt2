;; This file was generated by EverParse 262e9327d5ec0317d8bfd1c880bd64244272a99d and z3 648e05754c37220f1fbb5943b4e69545d82b7bae
;; Command line: $EVERPARSE_HOME/bin/3d.exe --z3_test TestMessage._message --z3_branch_depth 2 --z3_witnesses 3 TestMessage.3d --save_z3_transcript test1.smt2

;; To z3

(set-option :produce-models true)
(declare-datatypes () ((State (mk-state (input-size Int) (choice-index Int) (branch-index Int)))))
(declare-datatypes () ((Result (mk-result (return-value Int) (after-state State)))))

; From EverParse3d.ErrorCode.is_range_okay
(define-fun is_range_okay ((size Int) (offset Int) (access_size Int)) Bool
  (and
    (>= size access_size)
    (>= (- size access_size) offset)
  )
)

(define-fun parse-empty ((x State)) Result
  (mk-result 0 x)
)

(declare-fun choose (Int) Int)
(assert (forall ((i Int))
  (and (<= 0 (choose i)) (< (choose i) 256))
))

(declare-fun branch-trace (Int) Int)

(define-fun parse-false ((x State)) State
  (mk-state -1 (choice-index x) (branch-index x))
)

(define-fun parse-all-bytes ((x State)) State
  (if (<= (input-size x) 0)
    x
    (mk-state 0 (+ (choice-index x) (input-size x)) (branch-index x))
  )
)

(define-fun parse-all-zeros ((x State)) State
  (if (<= (input-size x) 0)
    x
    (mk-state
      (if
        (forall ((j Int))
          (if (and (<= 0 j) (< j (input-size x)))
            (= (choose (+ (choice-index x) j)) 0)
            true
          )
        )
        0
        -1
      )
      (+ (choice-index x) (input-size x))
      (branch-index x)
    )
  )
)

(define-fun parse-u8 ((x State)) Result
  (mk-result
    (choose (choice-index x))
    (mk-state
      (let ((new-size (- (input-size x) 1)))
        (if (< new-size 0)
          -1
          new-size
        )
      )
      (+ (choice-index x) 1)
      (branch-index x)
    )
  )
)

(define-fun parse-u16-be ((x State)) Result
  (mk-result
    (+ (choose (+ 1 (choice-index x)))
      (* 256
        (choose (+ 0 (choice-index x)))
      )
    )
    (mk-state
      (let ((new-size (- (input-size x) 2)))
        (if (< new-size 0)
          -1
          new-size
        )
      )
      (+ (choice-index x) 2)
      (branch-index x)
    )
  )
)

(define-fun parse-u16-le ((x State)) Result
  (mk-result
    (+ (choose (+ 0 (choice-index x)))
      (* 256
        (choose (+ 1 (choice-index x)))
      )
    )
    (mk-state
      (let ((new-size (- (input-size x) 2)))
        (if (< new-size 0)
          -1
          new-size
        )
      )
      (+ (choice-index x) 2)
      (branch-index x)
    )
  )
)

(define-fun parse-u32-be ((x State)) Result
  (mk-result
    (+ (choose (+ 3 (choice-index x)))
      (* 256
        (+ (choose (+ 2 (choice-index x)))
          (* 256
            (+ (choose (+ 1 (choice-index x)))
              (* 256
                (choose (+ 0 (choice-index x)))
              )
            )
          )
        )
      )
    )
    (mk-state
      (let ((new-size (- (input-size x) 4)))
        (if (< new-size 0)
          -1
          new-size
        )
      )
      (+ (choice-index x) 4)
      (branch-index x)
    )
  )
)

(define-fun parse-u32-le ((x State)) Result
  (mk-result
    (+ (choose (+ 0 (choice-index x)))
      (* 256
        (+ (choose (+ 1 (choice-index x)))
          (* 256
            (+ (choose (+ 2 (choice-index x)))
              (* 256
                (choose (+ 3 (choice-index x)))
              )
            )
          )
        )
      )
    )
    (mk-state
      (let ((new-size (- (input-size x) 4)))
        (if (< new-size 0)
          -1
          new-size
        )
      )
      (+ (choice-index x) 4)
      (branch-index x)
    )
  )
)

(define-fun parse-u64-be ((x State)) Result
  (mk-result
    (+ (choose (+ 7 (choice-index x)))
      (* 256
        (+ (choose (+ 6 (choice-index x)))
          (* 256
            (+ (choose (+ 5 (choice-index x)))
              (* 256
                (+ (choose (+ 4 (choice-index x)))
                  (* 256
                    (+ (choose (+ 3 (choice-index x)))
                      (* 256
                        (+ (choose (+ 2 (choice-index x)))
                          (* 256
                            (+ (choose (+ 1 (choice-index x)))
                              (* 256
                                (choose (+ 0 (choice-index x)))
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
    (mk-state
      (let ((new-size (- (input-size x) 8)))
        (if (< new-size 0)
          -1
          new-size
        )
      )
      (+ (choice-index x) 8)
      (branch-index x)
    )
  )
)

(define-fun parse-u64-le ((x State)) Result
  (mk-result
    (+ (choose (+ 0 (choice-index x)))
      (* 256
        (+ (choose (+ 1 (choice-index x)))
          (* 256
            (+ (choose (+ 2 (choice-index x)))
              (* 256
                (+ (choose (+ 3 (choice-index x)))
                  (* 256
                    (+ (choose (+ 4 (choice-index x)))
                      (* 256
                        (+ (choose (+ 5 (choice-index x)))
                          (* 256
                            (+ (choose (+ 6 (choice-index x)))
                              (* 256
                                (choose (+ 7 (choice-index x)))
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
    (mk-state
      (let ((new-size (- (input-size x) 8)))
        (if (< new-size 0)
          -1
          new-size
        )
      )
      (+ (choice-index x) 8)
      (branch-index x)
    )
  )
)

(define-fun-rec pow-2 ((amount Int)) Int
  (if (<= amount 0)
    1
    (* 2 (pow-2 (- amount 1)))
  )
)

;; see LowParse.BitFields.get_bitfield_eq
(define-fun get-bitfield-lsb ((nbBits Int) (value Int) (bitsFrom Int) (bitsTo Int)) Int
  (mod (div value (pow-2 bitsFrom)) (pow-2 (- bitsTo bitsFrom)))
)

;; see EverParse3d.Prelude.StaticHeader
(define-fun get-bitfield-msb ((nbBits Int) (value Int) (bitsFrom Int) (bitsTo Int)) Int
  (get-bitfield-lsb nbBits value (- nbBits bitsTo) (- nbBits bitsFrom))
)

;; see EverParse3d.Actions.Base.validate_nlist_total_constant_size
(define-fun parse-nlist-total-constant-size ((size Int) (eltSize Int) (x State)) State
  (if (< (input-size x) 0)
    x
    (if (and (= 0 (mod size eltSize)) (>= (input-size x) size))
      (mk-state
        (- (input-size x) size)
        (+ (choice-index x) size)
        (branch-index x)
      )
      (mk-state
        -1
        (choice-index x)
        (branch-index x)
      )
    )
  )
)

(declare-const initial-input-size Int)
(assert (>= initial-input-size 0))
(define-fun initial-state () State (mk-state initial-input-size 0 0))

(define-fun TestMessage._message-payload ((first Int) (TestMessage._message-payload-input State)) State
   (after-state (parse-u8 TestMessage._message-payload-input))
 )
(define-fun TestMessage._message ((TestMessage._message-input State)) State
   (let ((TestMessage._message-tmp (parse-u8 TestMessage._message-input)))
     (if (< (input-size (after-state TestMessage._message-tmp)) 0)
       (after-state TestMessage._message-tmp)
       (let ((TestMessage._message-condtmp (let ((first (return-value TestMessage._message-tmp))) (> first 42))))
         (if (and TestMessage._message-condtmp (or (< (branch-index (after-state TestMessage._message-tmp)) 0) (= (branch-trace (branch-index (after-state TestMessage._message-tmp))) 0)))
           (let ((first (return-value TestMessage._message-tmp)))
             (TestMessage._message-payload first
               (mk-state
                 (input-size (after-state TestMessage._message-tmp))
                 (choice-index (after-state TestMessage._message-tmp))
                 (+ (if (< (branch-index (after-state TestMessage._message-tmp)) 0) 0 1) (branch-index (after-state TestMessage._message-tmp)))
               )
             )
           )
           (mk-state
             (if (and (not TestMessage._message-condtmp) (or (< (branch-index (after-state TestMessage._message-tmp)) 0) (= (branch-trace (branch-index (after-state TestMessage._message-tmp))) 1))) -1 -2)
             (choice-index (after-state TestMessage._message-tmp))
             (+ (if (< (branch-index (after-state TestMessage._message-tmp)) 0) 0 1) (branch-index (after-state TestMessage._message-tmp)))
           )
         )
       )
     )
   )
 )

(push)



(define-fun state-witness () State (TestMessage._message initial-state))
(define-fun state-witness-input-size () Int (input-size state-witness))
(declare-fun state-witness-size () Int)
(assert (<= state-witness-size (choice-index state-witness)))
(assert (>= state-witness-size (choice-index state-witness)))

(push)

(assert (> (branch-index state-witness) 0))

(check-sat)

;; From z3
; sat
;; To z3
(push)

(assert (= (branch-trace 0) 0))

(check-sat)

;; From z3
; sat
;; To z3
(push)

(assert (or (= state-witness-input-size -1) (= state-witness-input-size 0)))

(check-sat)

;; From z3
; sat
;; To z3
(pop)

(assert (> (branch-index state-witness) 1))

(check-sat)

;; From z3
; unsat
;; To z3
(pop)

(push)

(assert (= (branch-trace 0) 1))

(check-sat)

;; From z3
; sat
;; To z3
(push)

(assert (or (= state-witness-input-size -1) (= state-witness-input-size 0)))

(check-sat)

;; From z3
; sat
;; To z3
(pop)

(assert (> (branch-index state-witness) 1))

(check-sat)

;; From z3
; unsat
;; To z3
(pop)

(push)

(assert (= (branch-trace 0) 2))

(check-sat)

;; From z3
; sat
;; To z3
(push)

(assert (or (= state-witness-input-size -1) (= state-witness-input-size 0)))

(check-sat)

;; From z3
; unsat
;; To z3
(pop)

(pop)

(pop)

(assert (or (= state-witness-input-size -1) (= state-witness-input-size 0)))

(push)


(assert (= (input-size state-witness) 0)) ; validator shall consume all input

(check-sat)

;; From z3
; sat
;; To z3
(get-value (state-witness-size))

;; From z3
; ((state-witness-size 2))
;; To z3
(eval (choose 1))

;; From z3
; 43
;; To z3
(eval (choose 0))

;; From z3
; 43
;; To z3
(assert (not (and (= (choose 1) 43) (and (= (choose 0) 43) (= (choice-index state-witness) 2)))))

(check-sat)

;; From z3
; sat
;; To z3
(get-value (state-witness-size))

;; From z3
; ((state-witness-size 2))
;; To z3
(eval (choose 1))

;; From z3
; 44
;; To z3
(eval (choose 0))

;; From z3
; 44
;; To z3
(assert (not (and (= (choose 1) 44) (and (= (choose 0) 44) (= (choice-index state-witness) 2)))))

(check-sat)

;; From z3
; sat
;; To z3
(get-value (state-witness-size))

;; From z3
; ((state-witness-size 2))
;; To z3
(eval (choose 1))

;; From z3
; 45
;; To z3
(eval (choose 0))

;; From z3
; 45
;; To z3
(assert (not (and (= (choose 1) 45) (and (= (choose 0) 45) (= (choice-index state-witness) 2)))))

(assert (> (branch-index state-witness) 0))

(push)

(assert (= (branch-trace 0) 0))

(check-sat)

;; From z3
; sat
;; To z3
(get-value (state-witness-size))

;; From z3
; ((state-witness-size 2))
;; To z3
(eval (choose 1))

;; From z3
; 46
;; To z3
(eval (choose 0))

;; From z3
; 46
;; To z3
(assert (not (and (= (choose 1) 46) (and (= (choose 0) 46) (= (choice-index state-witness) 2)))))

(check-sat)

;; From z3
; sat
;; To z3
(get-value (state-witness-size))

;; From z3
; ((state-witness-size 2))
;; To z3
(eval (choose 1))

;; From z3
; 0
;; To z3
(eval (choose 0))

;; From z3
; 45
;; To z3
(assert (not (and (= (choose 1) 0) (and (= (choose 0) 45) (= (choice-index state-witness) 2)))))

(check-sat)

;; From z3
; sat
;; To z3
(get-value (state-witness-size))

;; From z3
; ((state-witness-size 2))
;; To z3
(eval (choose 1))

;; From z3
; 47
;; To z3
(eval (choose 0))

;; From z3
; 45
;; To z3
(assert (not (and (= (choose 1) 47) (and (= (choose 0) 45) (= (choice-index state-witness) 2)))))

(assert (> (branch-index state-witness) 1))

(pop)

(push)

(assert (= (branch-trace 0) 1))

(check-sat)

;; From z3
; unsat
;; To z3
(assert (> (branch-index state-witness) 1))

(pop)

(pop)

(push)


(assert (= state-witness-input-size -1)) ; validator shall genuinely fail, we are not interested in positive cases followed by garbage

(check-sat)

;; From z3
; sat
;; To z3
(get-value (state-witness-size))

;; From z3
; ((state-witness-size 1))
;; To z3
(eval (choose 0))

;; From z3
; 43
;; To z3
(assert (not (and (= (choose 0) 43) (= (choice-index state-witness) 1))))

(check-sat)

;; From z3
; sat
;; To z3
(get-value (state-witness-size))

;; From z3
; ((state-witness-size 1))
;; To z3
(eval (choose 0))

;; From z3
; 44
;; To z3
(assert (not (and (= (choose 0) 44) (= (choice-index state-witness) 1))))

(check-sat)

;; From z3
; sat
;; To z3
(get-value (state-witness-size))

;; From z3
; ((state-witness-size 1))
;; To z3
(eval (choose 0))

;; From z3
; 45
;; To z3
(assert (not (and (= (choose 0) 45) (= (choice-index state-witness) 1))))

(assert (> (branch-index state-witness) 0))

(push)

(assert (= (branch-trace 0) 0))

(check-sat)

;; From z3
; sat
;; To z3
(get-value (state-witness-size))

;; From z3
; ((state-witness-size 2))
;; To z3
(eval (choose 1))

;; From z3
; 45
;; To z3
(eval (choose 0))

;; From z3
; 45
;; To z3
(assert (not (and (= (choose 1) 45) (and (= (choose 0) 45) (= (choice-index state-witness) 2)))))

(check-sat)

;; From z3
; sat
;; To z3
(get-value (state-witness-size))

;; From z3
; ((state-witness-size 2))
;; To z3
(eval (choose 1))

;; From z3
; 46
;; To z3
(eval (choose 0))

;; From z3
; 46
;; To z3
(assert (not (and (= (choose 1) 46) (and (= (choose 0) 46) (= (choice-index state-witness) 2)))))

(check-sat)

;; From z3
; sat
;; To z3
(get-value (state-witness-size))

;; From z3
; ((state-witness-size 2))
;; To z3
(eval (choose 1))

;; From z3
; 44
;; To z3
(eval (choose 0))

;; From z3
; 44
;; To z3
(assert (not (and (= (choose 1) 44) (and (= (choose 0) 44) (= (choice-index state-witness) 2)))))

(assert (> (branch-index state-witness) 1))

(pop)

(push)

(assert (= (branch-trace 0) 1))

(check-sat)

;; From z3
; sat
;; To z3
(get-value (state-witness-size))

;; From z3
; ((state-witness-size 1))
;; To z3
(eval (choose 0))

;; From z3
; 42
;; To z3
(assert (not (and (= (choose 0) 42) (= (choice-index state-witness) 1))))

(check-sat)

;; From z3
; sat
;; To z3
(get-value (state-witness-size))

;; From z3
; ((state-witness-size 1))
;; To z3
(eval (choose 0))

;; From z3
; 41
;; To z3
(assert (not (and (= (choose 0) 41) (= (choice-index state-witness) 1))))

(check-sat)

;; From z3
; sat
;; To z3
(get-value (state-witness-size))

;; From z3
; ((state-witness-size 1))
;; To z3
(eval (choose 0))

;; From z3
; 40
;; To z3
(assert (not (and (= (choose 0) 40) (= (choice-index state-witness) 1))))

(assert (> (branch-index state-witness) 1))

(pop)

(pop)

(pop)


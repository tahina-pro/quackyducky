
(declare-datatypes (T1 T2) ((Pair (mk-pair (first T1) (second T2)))))

(define-fun parse-empty ((x (Seq Int))) (Seq (Pair Int Int))
  (seq.unit (mk-pair 0 0))
)

(define-fun parse-u8 ((x (Seq Int))) (Seq (Pair Int Int))
  (if (= (seq.len x) 0)
    (as seq.empty (Seq (Pair Int Int)))
    (seq.unit (mk-pair (seq.nth x 0) 1))
  )
)

(define-fun parse-fail ((x (Seq Int))) (Seq Int)
  (as seq.empty (Seq Int))
)
(define-fun p-payload-else-payload-else ((y Int) (x Int) (p-payload-else-payload-else-input (Seq Int))) (Seq Int)
   (let ((p-payload-else-payload-else-tmp (parse-empty p-payload-else-payload-else-input)))
     (if (= (seq.len p-payload-else-payload-else-tmp) 0)
       (as seq.empty (Seq Int))
       (seq.unit (second (seq.nth p-payload-else-payload-else-tmp 0)))
     )
   )
 )
(define-fun p-payload-else-payload ((y Int) (x Int) (p-payload-else-payload-input (Seq Int))) (Seq Int)
   (if (> (+ x y) 30)
     (parse-fail p-payload-else-payload-input)
     (p-payload-else-payload-else y x p-payload-else-payload-input)
   )
 )
(define-fun p-payload-else ((x Int) (p-payload-else-input (Seq Int))) (Seq Int)
   (let ((p-payload-else-tmp-has-tag (parse-u8 p-payload-else-input)))
     (if (= (seq.len p-payload-else-tmp-has-tag) 0)
       (as seq.empty (Seq Int))
       (let ((p-payload-else-tmp-tag-result (seq.nth p-payload-else-tmp-has-tag 0)))
         (let ((y (first p-payload-else-tmp-tag-result)))
           (let ((p-payload-else-tmp-payload (p-payload-else-payload y x (seq.extract p-payload-else-input (second p-payload-else-tmp-tag-result) (- (seq.len p-payload-else-input) (second p-payload-else-tmp-tag-result))))))
             (if (= (seq.len p-payload-else-tmp-payload) 0)
               (as seq.empty (Seq Int))
               (seq.unit (+ (second p-payload-else-tmp-tag-result) (seq.nth p-payload-else-tmp-payload 0)))
             )
           )
         )
       )
     )
   )
 )(define-fun p-payload ((x Int) (p-payload-input (Seq Int))) (Seq Int)
   (if (< x 10)
     (parse-fail p-payload-input)
     (p-payload-else x p-payload-input)
   )
 )
(define-fun p ((p-input (Seq Int))) (Seq Int)
   (let ((p-tmp-has-tag (parse-u8 p-input)))
     (if (= (seq.len p-tmp-has-tag) 0)
       (as seq.empty (Seq Int))
       (let ((p-tmp-tag-result (seq.nth p-tmp-has-tag 0)))
         (let ((x (first p-tmp-tag-result)))
           (let ((p-tmp-payload (p-payload x (seq.extract p-input (second p-tmp-tag-result) (- (seq.len p-input) (second p-tmp-tag-result))))))
             (if (= (seq.len p-tmp-payload) 0)
               (as seq.empty (Seq Int))
               (seq.unit (+ (second p-tmp-tag-result) (seq.nth p-tmp-payload 0)))
             )
           )
         )
       )
     )
   )
 )
(declare-const witness (Seq Int))
(assert (forall ((x Int)) (if (and (<= 0 x) (< x (seq.len witness))) (and (<= 0 (seq.nth witness x)) (< (seq.nth witness x) 256)) true)))
(assert (= (seq.len (p witness)) 1))
(check-sat)
(get-model)

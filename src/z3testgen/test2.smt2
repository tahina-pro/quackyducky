
(declare-datatypes (T1 T2) ((Pair (mk-pair (first T1) (second T2)))))

(define-fun parse-empty ((x (Seq Int))) (Seq (Pair Int Int))
  (seq.unit (mk-pair 0 0))
)

(define-fun parse-u8 ((x (Seq Int))) (Seq (Pair Int Int))
  (if (= (seq.len x) 0)
    (as seq.empty (Seq (Pair Int Int)))
    (seq.unit (mk-pair (seq.nth x 0) 1))
  )
)

(define-fun parse-fail ((x (Seq Int))) (Seq Int)
  (as seq.empty (Seq Int))
)
(define-fun p-payload-else-payload-else ((y Int) (x Int) (p-payload-else-payload-else-input (Seq Int))) (Seq Int)
   (let ((p-payload-else-payload-else-tmp (parse-empty p-payload-else-payload-else-input)))
     (if (= (seq.len p-payload-else-payload-else-tmp) 0)
       (as seq.empty (Seq Int))
       (seq.unit (second (seq.nth p-payload-else-payload-else-tmp 0)))
     )
   )
 )
(define-fun p-payload-else-payload ((y Int) (x Int) (p-payload-else-payload-input (Seq Int))) (Seq Int)
   (if (> (+ x y) 30)
     (parse-fail p-payload-else-payload-input)
     (p-payload-else-payload-else y x p-payload-else-payload-input)
   )
 )
(define-fun p-payload-else ((x Int) (p-payload-else-input (Seq Int))) (Seq Int)
   (let ((p-payload-else-tmp-has-tag (parse-u8 p-payload-else-input)))
     (if (= (seq.len p-payload-else-tmp-has-tag) 0)
       (as seq.empty (Seq Int))
       (let ((p-payload-else-tmp-tag-result (seq.nth p-payload-else-tmp-has-tag 0)))
         (let ((y (first p-payload-else-tmp-tag-result)))
           (let ((p-payload-else-tmp-payload (p-payload-else-payload y x (seq.extract p-payload-else-input (second p-payload-else-tmp-tag-result) (- (seq.len p-payload-else-input) (second p-payload-else-tmp-tag-result))))))
             (if (= (seq.len p-payload-else-tmp-payload) 0)
               (as seq.empty (Seq Int))
               (seq.unit (+ (second p-payload-else-tmp-tag-result) (seq.nth p-payload-else-tmp-payload 0)))
             )
           )
         )
       )
     )
   )
 )(define-fun p-payload ((x Int) (p-payload-input (Seq Int))) (Seq Int)
   (if (< x 10)
     (parse-fail p-payload-input)
     (p-payload-else x p-payload-input)
   )
 )
(define-fun p ((p-input (Seq Int))) (Seq Int)
   (let ((p-tmp-has-tag (parse-u8 p-input)))
     (if (= (seq.len p-tmp-has-tag) 0)
       (as seq.empty (Seq Int))
       (let ((p-tmp-tag-result (seq.nth p-tmp-has-tag 0)))
         (let ((x (first p-tmp-tag-result)))
           (let ((p-tmp-payload (p-payload x (seq.extract p-input (second p-tmp-tag-result) (- (seq.len p-input) (second p-tmp-tag-result))))))
             (if (= (seq.len p-tmp-payload) 0)
               (as seq.empty (Seq Int))
               (seq.unit (+ (second p-tmp-tag-result) (seq.nth p-tmp-payload 0)))
             )
           )
         )
       )
     )
   )
 )(define-fun q-payload-else-payload-else ((y Int) (x Int) (q-payload-else-payload-else-input (Seq Int))) (Seq Int)
   (let ((q-payload-else-payload-else-tmp (parse-empty q-payload-else-payload-else-input)))
     (if (= (seq.len q-payload-else-payload-else-tmp) 0)
       (as seq.empty (Seq Int))
       (seq.unit (second (seq.nth q-payload-else-payload-else-tmp 0)))
     )
   )
 )
(define-fun q-payload-else-payload ((y Int) (x Int) (q-payload-else-payload-input (Seq Int))) (Seq Int)
   (if (> (+ x y) 28)
     (parse-fail q-payload-else-payload-input)
     (q-payload-else-payload-else y x q-payload-else-payload-input)
   )
 )
(define-fun q-payload-else ((x Int) (q-payload-else-input (Seq Int))) (Seq Int)
   (let ((q-payload-else-tmp-has-tag (parse-u8 q-payload-else-input)))
     (if (= (seq.len q-payload-else-tmp-has-tag) 0)
       (as seq.empty (Seq Int))
       (let ((q-payload-else-tmp-tag-result (seq.nth q-payload-else-tmp-has-tag 0)))
         (let ((y (first q-payload-else-tmp-tag-result)))
           (let ((q-payload-else-tmp-payload (q-payload-else-payload y x (seq.extract q-payload-else-input (second q-payload-else-tmp-tag-result) (- (seq.len q-payload-else-input) (second q-payload-else-tmp-tag-result))))))
             (if (= (seq.len q-payload-else-tmp-payload) 0)
               (as seq.empty (Seq Int))
               (seq.unit (+ (second q-payload-else-tmp-tag-result) (seq.nth q-payload-else-tmp-payload 0)))
             )
           )
         )
       )
     )
   )
 )(define-fun q-payload ((x Int) (q-payload-input (Seq Int))) (Seq Int)
   (if (< x 12)
     (parse-fail q-payload-input)
     (q-payload-else x q-payload-input)
   )
 )
(define-fun q ((q-input (Seq Int))) (Seq Int)
   (let ((q-tmp-has-tag (parse-u8 q-input)))
     (if (= (seq.len q-tmp-has-tag) 0)
       (as seq.empty (Seq Int))
       (let ((q-tmp-tag-result (seq.nth q-tmp-has-tag 0)))
         (let ((x (first q-tmp-tag-result)))
           (let ((q-tmp-payload (q-payload x (seq.extract q-input (second q-tmp-tag-result) (- (seq.len q-input) (second q-tmp-tag-result))))))
             (if (= (seq.len q-tmp-payload) 0)
               (as seq.empty (Seq Int))
               (seq.unit (+ (second q-tmp-tag-result) (seq.nth q-tmp-payload 0)))
             )
           )
         )
       )
     )
   )
 )
(declare-const witness (Seq Int))
(assert (forall ((j Int))
  (if (and (<= 0 j) (< j (seq.len witness)))
    (let ((witnessj (seq.nth witness j)))
      (and (<= 0 witnessj) (< witnessj 256))
    )
    true
  )
))
(assert (and (= (seq.len (p witness)) 1) (= (seq.len (q witness)) 0)))
(check-sat)
(get-value (witness))

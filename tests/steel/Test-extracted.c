/* 
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>
  KaRaMeL invocation: /home/tahina/everest/steel/karamel/krml -ccopt -Ofast -drop FStar.Tactics.\* -drop FStar.Tactics -drop FStar.Reflection.\* -tmpdir out -I .. -bundle Test=Steel.\*,C,LowParse.\* -add-include "krml/internal/compat.h" -warn-error @2 -no-prefix Test krml/FStar_Pervasives_Native.krml krml/FStar_Pervasives.krml krml/FStar_Mul.krml krml/FStar_Squash.krml krml/FStar_Classical.krml krml/FStar_Preorder.krml krml/FStar_Calc.krml krml/FStar_StrongExcludedMiddle.krml krml/FStar_Classical_Sugar.krml krml/FStar_List_Tot_Base.krml krml/FStar_List_Tot_Properties.krml krml/FStar_List_Tot.krml krml/FStar_Seq_Base.krml krml/FStar_Seq_Properties.krml krml/FStar_Seq.krml krml/FStar_Math_Lib.krml krml/FStar_Math_Lemmas.krml krml/FStar_BitVector.krml krml/FStar_UInt.krml krml/FStar_UInt32.krml krml/FStar_Int.krml krml/FStar_Int16.krml krml/FStar_Real.krml krml/FStar_Universe.krml krml/FStar_Monotonic_Pure.krml krml/FStar_Ghost.krml krml/FStar_PCM.krml krml/FStar_Range.krml krml/FStar_Tactics_Common.krml krml/FStar_VConfig.krml krml/FStar_Reflection_Types.krml krml/FStar_Tactics_Types.krml krml/FStar_Tactics_Result.krml krml/FStar_Tactics_Effect.krml krml/FStar_Reflection_Data.krml krml/FStar_Tactics_Builtins.krml krml/FStar_FunctionalExtensionality.krml krml/FStar_Set.krml krml/FStar_IndefiniteDescription.krml krml/FStar_PropositionalExtensionality.krml krml/FStar_PredicateExtensionality.krml krml/FStar_WellFounded.krml krml/FStar_Reflection_Const.krml krml/FStar_Order.krml krml/FStar_Reflection_Builtins.krml krml/FStar_Reflection_Derived.krml krml/FStar_Reflection_Derived_Lemmas.krml krml/FStar_Reflection.krml krml/FStar_Tactics_Print.krml krml/FStar_Tactics_SyntaxHelpers.krml krml/FStar_Tactics_Util.krml krml/FStar_Reflection_Formula.krml krml/FStar_Tactics_Derived.krml krml/FStar_Tactics_Logic.krml krml/FStar_Tactics.krml krml/FStar_Exn.krml krml/FStar_Monotonic_Witnessed.krml krml/FStar_ErasedLogic.krml krml/FStar_TSet.krml krml/FStar_Monotonic_Heap.krml krml/FStar_Heap.krml krml/FStar_ST.krml krml/FStar_All.krml krml/FStar_List.krml krml/FStar_Char.krml krml/FStar_String.krml krml/FStar_Tactics_CanonCommSwaps.krml krml/FStar_Algebra_CommMonoid_Equiv.krml krml/FStar_Tactics_CanonCommMonoidSimple_Equiv.krml krml/Steel_Loops.krml krml/LowParse_Steel_StdInt.krml krml/FStar_Map.krml krml/LowParse_SteelST_ArrayPtr.krml krml/FStar_UInt8.krml krml/LowParse_Bytes.krml krml/LowParse_Norm.krml krml/LowParse_Spec_Base.krml krml/LowParse_SteelST_Parse.krml krml/LowParse_SteelST_Access.krml krml/LowParse_SteelST_Validate.krml krml/LowParse_Spec_Combinators.krml krml/LowParse_Spec_List.krml krml/LowParse_SteelST_List.krml krml/FStar_UInt64.krml krml/LowParse_SteelST_Write.krml krml/FStar_Endianness.krml krml/LowParse_Spec_FLData.krml krml/LowParse_Spec_Seq.krml krml/FStar_UInt16.krml krml/LowParse_Spec_Int.krml krml/FStar_Monotonic_HyperHeap.krml krml/FStar_Monotonic_HyperStack.krml krml/FStar_HyperStack.krml krml/FStar_HyperStack_ST.krml krml/FStar_GSet.krml krml/FStar_ModifiesGen.krml krml/FStar_BigOps.krml krml/LowStar_Monotonic_Buffer.krml krml/LowStar_Buffer.krml krml/LowParse_Math.krml krml/LowParse_Spec_SeqBytes_Base.krml krml/FStar_Int64.krml krml/FStar_Int32.krml krml/FStar_Int8.krml krml/FStar_Int_Cast.krml krml/LowParse_Spec_BoundedInt.krml krml/LowParse_Spec_DER.krml krml/LowParse_Spec_BCVLI.krml krml/LowParse_Spec_AllIntegers.krml krml/LowParse_Spec_VLData.krml krml/LowParse_SteelST_FLData.krml krml/LowParse_SteelST_Combinators.krml krml/C.krml krml/LowParse_Endianness.krml krml/LowParse_Spec_Endianness.krml krml/LowParse_Spec_Endianness_Instances.krml krml/LowParse_SteelST_Endianness.krml krml/LowParse_SteelST_BoundedInt.krml krml/LowParse_SteelST_VLData.krml krml/LowParse_SteelST_Int.krml krml/Test.krml -o test.exe
  F* version: ccc334c7
  KaRaMeL version: c82c6e06
 */

#include "Test.h"



#define VALIDATOR_ERROR_NOT_ENOUGH_DATA ((uint32_t)1U)

typedef uint8_t __uint8_t___;

typedef __uint8_t___ *dtuple2___K___uint8_t_______;

uint32_t validate_p(uint8_t *a, uint32_t len, uint32_t *err)
{
  uint32_t len1;
  if ((uint32_t)1U <= len)
    len1 = (uint32_t)1U;
  else
  {
    err[0U] = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
    len1 = (uint32_t)0U;
  }
  uint32_t verr = err[0U];
  if (verr == (uint32_t)0U)
  {
    __uint8_t___ *a1 = a;
    __uint8_t___ *pt = a1;
    uint8_t last = pt[0U];
    uint32_t x = (uint32_t)last;
    uint32_t res;
    if (!(x <= len - len1))
    {
      err[0U] = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
      res = (uint32_t)0U;
    }
    else
    {
      uint32_t r = (uint32_t)0U;
      uint32_t len20 = r;
      uint32_t verr10 = err[0U];
      bool cond = len20 != x && verr10 == (uint32_t)0U;
      while (cond)
      {
        uint32_t len2 = r;
        uint32_t lenr = x - len2;
        uint32_t len11;
        if ((uint32_t)2U <= lenr)
          len11 = (uint32_t)2U;
        else
        {
          err[0U] = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
          len11 = (uint32_t)0U;
        }
        uint32_t verr10 = err[0U];
        if (!(verr10 != (uint32_t)0U))
          if (len11 == (uint32_t)0U)
            err[0U] = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
          else
          {
            uint32_t len_ = len2 + len11;
            r = len_;
          }
        uint32_t len20 = r;
        uint32_t verr1 = err[0U];
        cond = len20 != x && verr1 == (uint32_t)0U;
      }
      uint32_t s1 = x;
      res = s1;
    }
    uint32_t len2 = res;
    return len1 + len2;
  }
  else
    return len1;
}

uint16_t iter_max(uint8_t *a, uint32_t len)
{
  uint8_t *r = a;
  uint32_t r1 = len;
  uint16_t r2 = (uint16_t)0U;
  bool r3 = len != (uint32_t)0U;
  while (r3)
  {
    uint8_t *a1 = r;
    uint32_t alen = (uint32_t)2U;
    uint32_t i_ = alen;
    uint8_t *a_ = a1 + i_;
    uint16_t accu = r2;
    uint32_t pos_ = (uint32_t)1U;
    __uint8_t___ *a20 = a1;
    __uint8_t___ *pt = a20;
    uint8_t last = pt[pos_];
    __uint8_t___ *a2 = a1;
    __uint8_t___ *pt0 = a2;
    uint8_t last1 = pt0[0U];
    uint16_t n = (uint16_t)last1;
    uint16_t wa = (uint16_t)last + n * (uint16_t)256U;
    uint16_t res;
    if (accu <= wa)
      res = wa;
    else
      res = accu;
    uint16_t res0 = res;
    uint16_t res1 = res0;
    uint16_t accu_ = res1;
    uint32_t len1 = r1;
    uint32_t len_ = len1 - alen;
    r1 = len_;
    r = a_;
    r2 = accu_;
    r3 = len_ != (uint32_t)0U;
  }
  uint16_t v = r2;
  uint16_t v0 = v;
  uint16_t v1 = v0;
  uint16_t v2 = v1;
  uint16_t res = v2;
  uint16_t res0 = res;
  uint16_t res1 = res0;
  return res1;
}

uint16_t test(uint8_t *a, uint32_t len, uint32_t *perr)
{
  perr[0U] = (uint32_t)0U;
  uint32_t sz = validate_p(a, len, perr);
  uint32_t err = perr[0U];
  if (err == (uint32_t)0U)
  {
    __uint8_t___ *a1 = a;
    __uint8_t___ *pt = a1;
    uint8_t last = pt[0U];
    uint32_t acsz = (uint32_t)last;
    uint32_t sz1 = (uint32_t)1U;
    uint32_t i_ = sz1;
    uint8_t *ac = a + i_;
    uint16_t res = iter_max(ac, acsz);
    return res;
  }
  else
    return (uint16_t)0U;
}

exit_code main()
{
  return EXIT_SUCCESS;
}

